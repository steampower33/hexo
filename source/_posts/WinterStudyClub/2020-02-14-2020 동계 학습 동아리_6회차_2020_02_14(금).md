---
title:  "2020 동계 학습 동아리_6회차_2020_02_14(금)"
excerpt: "2020 동계 학습 동아리_6회차_2020_02_14(금)"

categories:
  - 2020동계학습동아리
tags:
  - Activity

toc: true
toc_label: "목차"
toc_icon: "clipboard-list"
last_modified_at: 2020-02-14T20:00:00+9:00
---

## 1. 문제

카카오코딩페스티벌2018 예선 E번 [음악추천](https://www.acmicpc.net/problem/15957)을 해결하기 이전에 이 문제에서 사용되는 이론과 관련된 유형의 문제를 해결한다.

## 2. 사용 이론

- 그래프
- 트리
- 병렬 이분 탐색

## 3. 풀이 이론

## 3-1.
- 문제가 원하는것은 사용자마다 음악을 추천해주는 알고리즘이다. 
- 곡의 수와 데이터의 수, 목표 점수가 주어지고, 그 다음 줄에는 무조건 1 1 로 루트가 주어진다음, 그 다음은 곡의 수 만큼 곡마다의 가수를 알려준다. 
- 트리의 순서로 가수가 정해진다고 보면된다. 그 다음 데이터의 수 만큼 데이터가 계산된 시간, 점수가 부여되는 서브트리의 루트가 되는 곳의 번호, 가중치가 들어온다. 이 가중치는 서브트리의 루트가 되는 노드의 모든 서브트리에 주어지는데 주어지는 방법은 가중치를 서브트리 개수만큼 나눈 몫이다. 
- 데이터 수 만큼 처리해준다음, 해당 곡을 부른 가수의 평균점수가 목표점수를 넘기면 데이터에서의 시간을 출력한다.

## 3-2. 

- 병렬 이분 탐색(parallel binary search)로 해결할 수 있다.
- 각각의 가수(singer)에 대해 몇 번째 쿼리까지 수행하면 가중치 평균이 J를 넘는지에 대해 이분 탐색을 한다.
- 이분 탐색을 수행하게 되는 중간값에 대해 오름차순 정렬하고 난 후, 트리를 탐색하면서 각 노드를 루트로 하는 서브트리의 가수들은 얼마의 가중치가 더해지게 되는지를 fenwick tree로 빠르게 계산할 수 있다.
- [출처](https://hongjun7.tistory.com/169)

## 3-3. 

- 추천이 여러 번 이루어지고 각각의 추천마다 여러 개의 노드의 값을 갱신하는 과정을 반복할 때, 지정된 값을 넘는 시점이 언제인지를 판단하는 문제입니다. 추천 횟수는 최대 10만 번이고 각각에 대해 값이 갱신되는 노드가 최대 10만 개이므로 단순히 값을 하나씩 갱신하는 방식으로는 시간 안에 답을 구할 수 없습니다.
- 트리 형태로 데이터가 주어지고, 서브트리 내의 모든 값에 일정한 값을 더하는 질의를 처리하기 위해서는 트리를 깊이 우선 탐색으로 방문하는 순서대로 원소를 나열하는 트리 순회 배열(Tree Traversal Array)을 만들고, 구간 트리(Segment Tree)를 사용하여 서브트리에 대응되는 구간의 값을 갱신하는 방식을 일반적으로 사용합니다.
- 특정 시점에 노드에 부여된 가중치를 구하는 과정은 노드마다 O(log N) 시간이 걸리기 때문에, 갱신이 이루어질 때마다 가중치의 합을 구하는 방식은 매우 비효율적입니다. 가중치의 합이 목표 점수를 언제 넘게 되는지만 구하면 되기 때문에, 목표 점수를 넘는 시간에 대한 이분 탐색을 진행할 경우, 특정한 가수의 평균 점수가 목표 점수를 넘는 시간을 O((K log N + N’ log N)log T) 시간에 계산할 수 있습니다. 이 때 N’은 해당 가수가 부른 곡의 수, 즉 노드의 개수이고 T는 시간의 최대 범위인 109입니다.
- 문제에서는 각 가수 별로 목표 점수를 넘게 되는 시점을 구해야 하므로, 위 과정을 모든 가수에 대해 반복할 경우 시간 안에 답을 구하기 힘듭니다. 이때 사용할 수 있는 방법이 병렬 이분 탐색(Parallel Binary Search)입니다. 이분 탐색은 구하는 값의 상한과 하한을 정한 다음 구간의 길이를 반으로 줄여나가는 과정을 반복하는 방법인데요, 구하는 값이 여러 개인 경우 각각에 대해 상한과 하한을 저장하는 배열을 정의한 뒤 한 번 계산할 때마다 모든 구간을 각각의 범위에 맞게 절반씩 줄여나갑니다. 
- 그러면 가수의 평균 점수를 계산하는 과정은 각 가수별로 진행해야 하지만 가중치를 부여하는 과정은 여러 번 반복할 필요가 없기 때문에 모든 가수에 대해 답을 계산하는 데 걸리는 시간이 O((K log N + N log N)log T)가 됩니다. 위 식과 비교하면 값을 갱신하는 과정의 시간 복잡도는 O(K log N log T)로 같으며, 가수별로 부른 곡의 수의 합이 N이 되므로 합을 계산하는 과정의 전체 시간이 O(N log N log T)가 됨을 알 수 있습니다.
- [출처](https://tech.kakao.com/2018/08/09/code-festival-2018-round-1/)

## 4. 해결

- [c++ 해결 출처](https://github.com/hongjun7/Competitive-Programming/blob/master/2018_KAKAO_CODEFESTIVAL_PRELIMINARIES/E.cpp)

## 5. 리뷰

카카오 코드 페스티벌은 수준이 매우 높다. 웬만한 실력으로는 해결할 수 없다. 알고리즘 수업때 조교님께서 말씀하셨다. 문제를 한번 읽고 아 이건 어떻게하면 풀수있겠다 하면 시도라도 할수있겠지만, 풀 방법이 생각이 나지않으면, 아예 그 문제는 풀수가 없다고 하셨다. 맞는 말씀이다. 그럼 풀수 없다면 어떻게 해야할까? 바로 다른 사람의 풀이를 참고한다. 하지만 인터넷상에 나와있는 다른 파이썬 풀이가 없다. c++ 코드는 있지만 설명과 해결방법이 없다. 이런 문제도 있구나 하는 걸 느꼈다. 오늘도 겸손해지는 날이다.